#!/usr/bin/perl
#
# LSB Scanner
# - Make LSB header changes persistent across init script updates.
# 
# This has two modes of operation; Pre-Scan and Post-Write
# 
# In Pre-Scan mode:
# - Read the LSB header of the named init script and records the chkconfig,
#   Required-Start, Should-Start, Required-Stop, Should-Stop, Default-Start,
#   Default-Stop and Default-Enabled. 
# - These will be stored as "variable = value" pairs in the destination
#   directory ('/etc/sysconfig by' default) under the name
#   '<program>.lsb.conf'.
# 
# In Post-Write mode:
# - The '<program>.lsb.conf' file will be read into memory.
# - The named '/etc/init.d/<program>' file will be read up to
#   '### END INIT INFO'.
# - The read value will be compared against the stored value, if any. If there
#   is a difference, the LSB line will be updated to match the stored value.
# - The modified init script will be re-written *only* if a value was changed.
# 
# Author:  Madison Kelly (mkelly@alteeve.com)
# Date:    Sep. 21, 2010
# License: GPL v2+
# 

# Play safe!
use strict;
use warnings;
use IO::Handle;
use File::Copy;

# Defaults.
my $conf={
	set_next	=>	"",
	'log'		=>	"/tmp/lsb_scanner.log",
	debug		=>	0,
	mode		=>	"",
	program		=>	"",
	src	=>	".",
	dst	=>	".",
# 	src	=>	"/etc/init.d",
# 	dst	=>	"/etc/sysconfig",
	from_conf	=>	{
		'chkconfig'		=>	undef,
		'Provides'		=>	undef,
		'Required-Start'	=>	undef,
		'Required-Stop'		=>	undef,
		'Should-Start'		=>	undef,
		'Should-Stop'		=>	undef,
		'Default-Start'		=>	undef,
		'Default-Stop'		=>	undef,
		'Default-Enabled'	=>	undef,
	},
};

# Make sure I am running as root.
# print "Real UID: [$<], Effective UID: [$>]\n";
die "The LSB Scanner must be run as root. Exiting.\n" if (($< != 0) && ($> != 0));

# Log file for output.
my $log=IO::Handle->new();
open ($log, ">>$conf->{'log'}") or die "Failed to open: [$conf->{'log'}] for writing; Error: $!\n";

# Set STDOUT and $log to hot (unbuffered) output.
if (1)
{
	select $log;
	$|=1;
	select STDOUT;
	$|=1;
}

# Read in arguments from the command line.
if (read_cla($conf, $log))
{
	record($conf, $log, __LINE__, "Exiting on errors reading command line argiments!\n", 2);
	help($conf, $log, 1);
}

# Sanity check
if (not $conf->{mode})
{
	record($conf, $log, __LINE__, "Mode was not set.\n", 2);
}
elsif (not $conf->{program})
{
	record($conf, $log, __LINE__, "Program was not defined.\n", 2);
}

# Replace some place holders.
my $program=$conf->{program};
$conf->{'log'}=~s/#!prog_name!#/$program/;
$conf->{src}.="/$program";
$conf->{dst}.="/lsb_scanner.$program.conf";
record ($conf, $log, __LINE__, "Log: [$conf->{'log'}], src: [$conf->{src}], dst: [$conf->{dst}]\n") if $conf->{debug};

# Start work.
if ($conf->{mode} eq "pre")
{
	# Read in the init script.
	read_init_lsb($conf, $log);
	write_lsb_conf($conf, $log);
}
elsif ($conf->{mode} eq "post")
{
}
else
{
	record($conf, $log, __LINE__, "Invalid mode! This should have been caught earlier and is likely the sign of a program error.\n", 2);
}

# This method can't pass in the '$log' handle, obviously, as it does not yet
# exist.
# read_conf($conf, $log);


do_exit($conf, $log, 1);

###############################################################################
# Functions                                                                   #
###############################################################################

# This writes out configuration files that were set in the read_init_lsb().
sub write_lsb_conf
{
	my ($conf, $log)=@_;
	
	my $lsb=IO::Handle->new();
	open ($lsb, ">$conf->{dst}") or die "Failed to open: [$conf->{dst}] for writing; Error: $!\n";
	
	foreach my $key (sort {$a cmp $b} keys %{$conf->{from_conf}})
	{
		print $lsb "$key: $conf->{from_conf}{$key}\n" if defined $conf->{from_conf}{$key};
	}
	$lsb->close();
	
	return 0;
}

# This reads in the init script up to the LSB header ending string.
sub read_init_lsb
{
	my ($conf, $log)=@_;
	
	if (not -f $conf->{src})
	{
		record($conf, $log, "Unable to find the source file: [$conf->{src}].\n", 2);
	}
	elsif (not -r $conf->{src})
	{
		record($conf, $log, "Unable to read the source file: [$conf->{src}], error was: $!\n", 2);
	}
	
	my $read=IO::Handle->new();
	my $shell_call="$conf->{src}";
	open ($read, "<$shell_call") or record($conf, $log, __LINE__, "Failed to read: [$shell_call], error was: $!\n", 2);
	record($conf, $log, __LINE__, "Shell call: [$shell_call]\n") if $conf->{debug};
	while (<$read>)
	{
		chomp;
		my $line=$_;
		next if not $line;
		# For safety reasons, I don't want to look at an uncommented
		# line.
		next if $line !~ /^#/;
		last if $line =~ /^### END INIT INFO/;
		# This regex doesn't work in some cases...
# 		my ($var, $val)=($line=~/^#\s+(\w+\-??\w{0,}): (.*)/);
		my ($var, $val)=split /:/, $line, 2;
		$var=~s/^#\s+//;
		next if not $var;
		next if not $val;
		$val=~s/^\s+//;
		$val=~s/\s+$//;
		foreach my $key (keys %{$conf->{from_conf}})
		{
			# If the hash key matches the variable, and if the
			# variable exists in the hash, store the value.
			if (($key eq $var) && (exists $conf->{from_conf}{$key}))
			{
				$conf->{from_conf}{$key}=$val;
				record ($conf, $log, __LINE__, "Set 'conf_file::$key' to: [$conf->{from_conf}{$key}]\n") if $conf->{debug};
				last;
			}
		}
	}
	$read->close();
	
	return (0);
}

# This returns the 'help' message.
sub help
{
	my ($conf, $log, $error)=@_;
	$error = 0 if not defined $error;
	
	# MADI: Convert this to 'man' formatting and then pipe it through
	#       man.
	print "\nFor more information on using lsb-scanner, please run 'man lsb-scanner'\n\n";
	
	do_exit($conf, $log, $error);
}

# Read in command line arguments
sub read_cla
{
	my ($conf, $log)=@_;
	
	my $bad = 0;
	
	# Loop through the passed arguments, if any.
	my $set_next="";
	while (@ARGV)
	{
		my $arg = shift @ARGV;
		my $val="";
		record($conf, $log, __LINE__, "Processing argument: [$arg].\n") if $conf->{debug};
		($arg, $val) = ($arg =~ /(-{1,2}\w+)=(\w+)/) if $arg=~ /=/;
		record($conf, $log, __LINE__, "Parsed argument: [$arg], value: [$val].\n") if $conf->{debug};
		
		if ($arg=~/-h/)
		{
			# Print the help message and then exit.
			help($conf, $log, 0);
		}
		elsif (($arg=~/-d/) || ($arg=~/--debug/))
		{
			# Turn on debugging output.
			$conf->{debug}=1;
		}
		elsif (($arg=~/-D/) || ($arg=~/--no-debug/))
		{
			# Turn off debugging output.
			$conf->{debug}=0;
		}
		elsif (($arg=~/-m/) || ($arg=~/--mode/))
		{
			# mode, must be 'pre' or 'post'
			$val = $val ? $val : shift @ARGV;
			record($conf, $log, __LINE__, "Value set to: [$val].\n") if $conf->{debug};
			if ((not $val) || ($val =~ /^-/))
			{
				record($conf, $log, __LINE__, "Bad argument! Passed '-m' without a mode. Must be 'pre' or 'post'.\n");
				$bad = 1;
			}
			elsif ((lc($val) ne "pre") && (lc($val) ne "post"))
			{
				record($conf, $log, __LINE__, "Bad mode! Got: [$val], must be 'pre' or 'post'.\n");
				$bad = 1;
			}
			else
			{
				$conf->{mode} = lc($val) eq "pre" ? "pre" : "post";
				record($conf, $log, __LINE__, "- Mode set to: [$conf->{mode}].\n") if $conf->{debug};
			}
		}
		elsif (($arg=~/-p/) || ($arg=~/--program/))
		{
			# program name.
			$val=$val ? $val : shift @ARGV;
			record($conf, $log, __LINE__, "Value set to: [$val].\n") if $conf->{debug};
			if ((not $val) || ($val =~ /^-/))
			{
				record($conf, $log, __LINE__, "Bad argument! Passed '-p' without a program name.\n");
				$bad = 1;
			}
			else
			{
				$conf->{program} = $val;
				record($conf, $log, __LINE__, "- Program set to: [$conf->{program}].\n") if $conf->{debug};
			}
		}
		else
		{
			# Bad argument.
			record($conf, $log, __LINE__, "\nERROR: Argument: [$arg] is not valid!\n");
			$bad=1;
		}
	}
	return ($bad);
}

# Read in the config file.
sub read_conf
{
	my ($conf, $log)=@_;
	$conf={} if not $conf;
	
	# I can't call the 'record' method here because I've not read in the
	# log file and thus don't know where to write the log to yet. Comment
	# out or delete 'print' statements before release.
	my $read=IO::Handle->new();
	my $shell_call="$conf->{conf_file}";
	open ($read, "<$shell_call") or record($conf, $log, __LINE__, "Failed to read: [$shell_call], error was: $!\n", 2);
	# To see this log message, debug will need to be set true in the
	# initialization hash.
	record($conf, $log, __LINE__, "Shell call: [$shell_call]\n") if $conf->{debug};
	while (<$read>)
	{
		chomp;
		my $line=$_;
		next if not $line;
		next if $line !~ /=/;
		$line=~s/^\s+//;
		$line=~s/\s+$//;
		next if $line =~ /^#/;
		next if not $line;
		my ($var, $val)=(split/=/, $line, 2);
		$var=~s/^\s+//;
		$var=~s/\s+$//;
		$val=~s/^\s+//;
		$val=~s/\s+$//;
		next if (not $var);
		record($conf, $log, __LINE__, "Storing: [$var] = [$val]\n") if $conf->{debug};
		$conf->{from_conf}{$var}={$val};
	}
	$read->close();
	
	return (0);
}

# This cleanly exits the agent.
sub do_exit
{
	my ($conf, $log, $exit_status)=@_;
	$exit_status=9 if not defined $exit_status;
	
	# Close the Node Assassin and log file handle, if they exist.
	$log->close() if $log;
	
	exit ($exit_status);
}

# This function simply prints messages to both the log and to stdout.
sub record
{
	my ($conf, $log, $line, $msg, $critical)=@_;
# 	print "line: [$line]\n";
	$critical=0 if not $critical;
	
	# The log file gets everything.
	print $log $msg;
	print $msg if not $conf->{quiet};
	
	# Critical messages have to print, so this ensure that it gets out
	# when 'quiet' is in use.
	print $msg if (($critical == 1) && ($conf->{quiet}));
	die "\nERROR: Fatal error at line: [$line]\nERROR: $msg\n" if $critical == 2;
	
	return(0);
}

exit 0;
